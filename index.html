
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>MediaPipe æ‰‹æŒ‡æ•æ‰‹éŠæˆ²</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* é˜²æ­¢æ²å‹• */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #container {
            position: relative;
            width: 1280px;
            height: 720px;
            background: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 10px;
        }

        /* å½±ç‰‡å…ƒç´ éš±è—ï¼Œæˆ‘å€‘åªç•«åœ¨ Canvas ä¸Š */
        #input_video {
            display: none;
        }

        #output_canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            transform: scaleX(-1); /* é¡åƒç¿»è½‰ï¼Œè®“æ“ä½œæ›´ç›´è¦º */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* è®“é»æ“Šç©¿é€ */
            display: flex;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .score-board {
            font-size: 40px;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            z-index: 10;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="container">
    <div id="loading">æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹ï¼Œè«‹ç¨å€™...<br>(è«‹å…è¨±æ”å½±æ©Ÿæ¬Šé™)</div>
    <video id="input_video"></video>
    <canvas id="output_canvas" width="1280" height="720"></canvas>
    
    <div id="ui-layer">
        <div class="score-board">å¾—åˆ†: <span id="score">0</span></div>
        </div>
</div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const scoreElement = document.getElementById('score');
    const loadingElement = document.getElementById('loading');

    let score = 0;
    let handPoint = { x: -1, y: -1 }; // å„²å­˜æ‰‹æŒ‡åº§æ¨™ (0-1)
    
    // éŠæˆ²ç‰©ä»¶è¨­å®š
    const items = [];
    const emojis = ['ğŸ', 'ğŸŒ', 'ğŸ‡', 'ğŸ‰', 'â­', 'ğŸ’', 'ğŸš€'];
    let lastSpawnTime = 0;
    const spawnRate = 1000; // æ¯«ç§’

    // åˆå§‹åŒ– MediaPipe Hands
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // æ”å½±æ©Ÿè¨­å®š
    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });
    camera.start();

    // ç•¶ MediaPipe åµæ¸¬åˆ°çµæœæ™‚åŸ·è¡Œ
    function onResults(results) {
        // éš±è—è¼‰å…¥æ–‡å­—
        loadingElement.style.display = 'none';

        // 1. æ¸…é™¤ç•«å¸ƒä¸¦ç¹ªè£½æ”å½±æ©Ÿç•«é¢
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        // 2. è™•ç†æ‰‹éƒ¨åµæ¸¬
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // ç¹ªè£½éª¨æ¶ (å¯é¸ï¼Œå¢åŠ ç§‘æŠ€æ„Ÿ)
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1});

            // å–å¾—é£ŸæŒ‡æŒ‡å°– (Index Finger Tip æ˜¯ç´¢å¼• 8)
            const indexTip = landmarks[8];
            handPoint = { x: indexTip.x, y: indexTip.y };
            
            // åœ¨æŒ‡å°–ç•«ä¸€å€‹å…‰åœˆ
            const px = handPoint.x * canvasElement.width;
            const py = handPoint.y * canvasElement.height;
            
            canvasCtx.beginPath();
            canvasCtx.arc(px, py, 15, 0, 2 * Math.PI);
            canvasCtx.fillStyle = "yellow";
            canvasCtx.fill();
            canvasCtx.lineWidth = 3;
            canvasCtx.strokeStyle = "orange";
            canvasCtx.stroke();
        } else {
            handPoint = { x: -1, y: -1 }; // æ²’åµæ¸¬åˆ°æ‰‹
        }

        // 3. åŸ·è¡ŒéŠæˆ²é‚è¼¯èˆ‡ç¹ªåœ–
        updateGame();

        canvasCtx.restore();
    }

    // éŠæˆ²é‚è¼¯è¿´åœˆ
    function updateGame() {
        const now = Date.now();
        const width = canvasElement.width;
        const height = canvasElement.height;

        // ç”Ÿæˆæ–°ç‰©å“
        if (now - lastSpawnTime > spawnRate) {
            spawnItem();
            lastSpawnTime = now;
        }

        // æ›´æ–°ä¸¦ç¹ªè£½ç‰©å“
        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i];
            
            // ç§»å‹•
            item.y += item.speed;

            // ç¹ªè£½
            canvasCtx.font = "40px Arial";
            canvasCtx.textAlign = "center";
            canvasCtx.textBaseline = "middle";
            canvasCtx.fillText(item.emoji, item.x, item.y);

            // ç¢°æ’åµæ¸¬ (æ‰‹æŒ‡ç¢°åˆ°ç‰©å“)
            // æ³¨æ„ï¼šå› ç‚ºåº§æ¨™ç³»æ˜¯ä¸€æ¨£çš„ (0-1 è½‰ pixels)ï¼Œç›´æ¥ç®—è·é›¢
            if (handPoint.x !== -1) {
                const fingerPx = handPoint.x * width;
                const fingerPy = handPoint.y * height;
                
                const dist = Math.hypot(fingerPx - item.x, fingerPy - item.y);
                
                if (dist < 40) { // ç¢°æ’åŠå¾‘
                    // å¾—åˆ†ï¼
                    score += 10;
                    scoreElement.innerText = score;
                    
                    // æ’­æ”¾ç‰¹æ•ˆ (é€™è£¡ç°¡å–®ç”¨é¡è‰²é–ƒçˆä»£æ›¿ï¼Œå¯¦éš›å¯åŠ ç²’å­ç‰¹æ•ˆ)
                    canvasCtx.fillStyle = "rgba(255, 255, 0, 0.5)";
                    canvasCtx.beginPath();
                    canvasCtx.arc(item.x, item.y, 50, 0, Math.PI*2);
                    canvasCtx.fill();

                    items.splice(i, 1); // ç§»é™¤ç‰©å“
                    continue;
                }
            }

            // è¶…å‡ºé‚Šç•Œç§»é™¤
            if (item.y > height) {
                items.splice(i, 1);
            }
        }
    }

    function spawnItem() {
        const width = canvasElement.width;
        items.push({
            x: Math.random() * (width - 100) + 50, // éš¨æ©Ÿ X
            y: -50, // å¾ä¸Šæ–¹é–‹å§‹
            speed: Math.random() * 3 + 2, // éš¨æ©Ÿé€Ÿåº¦
            emoji: emojis[Math.floor(Math.random() * emojis.length)]
        });
    }

</script>

</body>
</html>
